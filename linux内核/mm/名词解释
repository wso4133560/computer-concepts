# deamon
这个文件是Linux内核中DAMON（Data Access MONitor）的物理地址空间的原语。
DAMON是一个内核模块，用于监视应用程序的内存访问模式。
它可以用于分析应用程序的访问模式，以便在不牺牲应用程序性能的情况下，更好地管理内存。

# kasan
KASAN是一种内核模式，用于检测内核中的内存错误，例如使用未初始化的内存，使用已释放的内存，数组越界等。

# kfence
KFENCE，是一种内存错误检测工具。它通过在内存池中分配对象并在对象周围添加红色区域来检测内存错误。

# backing device
后备设备是指用于存储文件系统数据的设备，例如硬盘、SSD等。

# balloon driver
balloon driver 是一种虚拟化技术，它可以在运行虚拟机的主机上动态地调整虚拟机的内存大小。
当主机上的内存资源不足时，balloon driver 会将虚拟机中未使用的内存页面释放到主机上，从而释放内存资源。当主机上的内存资源充足时，balloon driver 会将这些页面还原到虚拟机中。
balloon driver 通常作为虚拟机监视器的一部分实现。

# balloon pages
balloon pages 是指被 balloon driver 从 guest system 中移除的页面。

# bootmem
在Linux内核启动时，内存管理子系统需要对系统中的物理内存进行管理，bootmem就是其中的一种管理方式。它的主要作用是在系统启动时，对物理内存进行管理，为内核提供内存分配服务。

# cleancache
cleancache是一种内核缓存，它可以在内存不足时释放缓存页，以便为新的缓存页腾出空间。
cleancache的实现分为前端和后端两部分，前端是内核中的cleancache代码，后端是由第三方提供的驱动程序。

# cma
Contiguous Memory Allocator（CMA）的实现。CMA是一种内核机制，用于在物理内存中分配连续的内存区域。
CMA的主要目的是为了支持一些需要连续内存的设备，例如视频缓冲区。CMA的实现使用了一个位图来跟踪哪些物理页面已经被分配，哪些页面是空闲的。

# 内存压缩
内存压缩使用的是页面迁移算法。具体来说，它通过将内存中的页面从一个物理地址移动到另一个物理地址来减少外部碎片。
在这个过程中，它会尝试将页面移动到一个更大的、连续的空闲区域，以便在未来的内存分配中更容易地找到足够大的连续空闲区域。

# DMA
DMA是直接内存访问的缩写，是一种计算机技术，它允许外部设备（如网络适配器、声卡等）直接访问系统内存，而不需要CPU的干预。
DMA可以提高数据传输的速度，减轻CPU的负担，提高系统的性能。DMA内存池是一种用于分配DMA内存的机制，它可以返回一些给定大小的小块，这些小块可以被给定设备进行DMA操作。

# ioremap
ioremap() 是一个内核函数，用于将物理地址映射到内核虚拟地址空间。它是在内核中使用的，以便内核可以访问设备的物理地址空间。
ioremap() 函数返回一个指向映射区域的指针，该区域可以用于访问设备的物理地址空间。

# 文件六种预读方式
POSIX_FADV_NORMAL：正常预读，预读的数据会被缓存到页缓存中。
POSIX_FADV_RANDOM：随机预读，预读的数据会被缓存到页缓存中。
POSIX_FADV_SEQUENTIAL：顺序预读，预读的数据会被缓存到页缓存中。
POSIX_FADV_WILLNEED：预读，预读的数据会被缓存到页缓存中。
POSIX_FADV_NOREUSE：不重用，释放的数据不会被重用。
POSIX_FADV_DONTNEED：释放，释放的数据会被释放掉。

# folio
folio是一种新的内存管理结构，它将页和slab合并为一个结构，以减少内存碎片和提高内存利用率。它是Linux 5.14版本中引入的新特性。

# Frontswap
Frontswap 是一种内存压缩技术，它可以将内存中的页面压缩并存储在磁盘上，以便在需要时进行快速访问。
Frontswap 的实现分为前端和后端两部分，前端是内核中的代码，后端是用户空间中的代码。
前端代码负责将页面压缩并将其存储在磁盘上，后端代码负责将页面从磁盘上读取并将其解压缩到内存中。
Frontswap 的实现依赖于内核中的 swap 子系统，因此需要在内核中启用 swap 子系统才能使用 Frontswap。

# highmem
高端内存是指物理内存地址空间的一部分，它不能直接被内核访问。
在32位系统中，物理地址空间的前1GB是直接映射到内核空间的，而剩余的3GB是映射到用户空间的。
因此，内核只能访问前1GB的物理地址空间。为了解决这个问题，内核引入了高端内存的概念。
高端内存是指物理地址空间中不能直接被内核访问的部分，它需要通过一些特殊的技术才能被内核访问。
在Linux内核中，高端内存的处理是通过highmem机制来实现的。

# kmap
kmap是一种内核映射机制，它允许内核将高端内存中的页面映射到内核地址空间中。在Linux内核中，kmap是通过kmap_high()函数来实现的。
kmap_high()函数将高端内存中的页面映射到内核地址空间中，并返回页面的虚拟地址。在使用完页面后，需要调用kunmap_high()函数来解除映射。

# HMM
HMM是一种内核机制，允许用户空间程序管理系统中的异构内存，包括GPU内存、NVDIMM、PMEM等。
HMM提供了一组API，允许用户空间程序管理这些内存，包括分配、释放、映射、反映射等。
这个文件实现了HMM的核心功能，包括页面缺失处理、页面映射、页面反映射等。

# huge_memory
大页是指比标准页（4KB）更大的页，它们的大小可以是2MB或1GB。大页可以提高内存访问效率，因为它们可以减少TLB（转换后援缓存）的使用，从而减少了内存访问的开销。

# 透明大页
透明大页是一种自动分配大页的机制，它可以在不修改应用程序的情况下提高应用程序的性能。
在透明大页机制下，内核会自动将一些标准页合并成大页，从而减少了TLB（转换后援缓存）的使用，从而减少了内存访问的开销。
透明大页是通过transparent_hugepage_flags变量来控制的，该变量定义在huge_memory.c文件中。

# 大页文件系统
大页文件系统是一种文件系统，它使用大页来存储文件数据，从而提高了文件系统的性能。大页文件系统是在透明大页的基础上实现的，它可以自动将文件数据存储在大页中，从而减少了内存访问的开销。

# hwpoison
用于在Linux内核中注入硬件错误的。它提供了一个debugfs接口，允许用户注入一个hwpoison内存故障到一个任意的PFN。

# 区间树
区间树是一种用于管理区间的数据结构。它可以高效地支持区间的插入、删除和查询操作。在Linux内核中，区间树被广泛应用于管理进程的虚拟内存区间和文件系统中的文件区间。

# io-mapping
用于将内核中的I/O映射映射到用户空间。它将一个物理地址映射到用户空间的一个虚拟地址。

# kmemleak
kmemleak是一种内核内存泄漏检测工具，它通过跟踪内核中的内存分配和释放来检测内存泄漏。
它通过在内核中跟踪内存分配和释放来检测内存泄漏。它通过在内核中跟踪内存分配和释放来检测内存泄漏。

# ksm
用于支持动态共享相同页面的功能。它允许在不同的内存区域中动态共享相同的页面，即使它们没有被fork()共享。这个模块的主要功能是将相同的页面合并到一起，以减少内存使用。

# LRU
LRU（Least Recently Used）机制是一种常用的缓存淘汰算法，它的基本思想是：当缓存满时，将最近最少使用的缓存块淘汰掉，以腾出空间存放新的缓存块。
在实现LRU机制时，通常使用链表来维护缓存块的使用顺序，每次访问缓存块时，将其移动到链表头部，这样链表尾部的缓存块就是最近最少使用的缓存块，可以被淘汰掉。

# maccess
主要提供了一些安全的内核和用户空间内存访问函数。这些函数可以在不引起内存访问异常的情况下，安全地访问内核和用户空间的内存。

# madvise
madvise系统调用可以用来通知内核有关进程的内存使用情况，以便内核可以更好地优化内存管理。

# 逻辑内存块
逻辑内存块是memblock中的一个概念，它是指系统内存的连续区域。在memblock中，有几种内存类型，包括memory、reserved和physmem。
每个区域由memblock_region结构表示，定义了区域范围、其属性和NUMA节点ID。每种内存类型都由memblock_type结构描述，其中包含一个内存区域数组以及分配器元数据。
memory和reserved类型使用memblock结构包装。这个结构在构建时静态初始化。区域数组最初的大小为INIT_MEMBLOCK_REGIONS（对于memory）和INIT_MEMBLOCK_RESERVED_REGIONS（对于reserved）。
对于physmem，区域数组的初始大小为INIT_PHYSMEM_REGIONS。

memory：描述内核可用的物理内存，这可能与实际安装在系统中的物理内存不同，例如当使用mem=命令行参数限制内存时。
reserved：描述已分配的区域。
physmem：描述在引导期间实际可用的物理内存，而不考虑可能的限制和内存热插拔；physmem类型仅在某些体系结构上可用。

# 在线内存
在线内存是指可以被操作系统使用的内存。在内存热插拔的过程中，我们可以将新的内存添加到系统中，然后在线内存，使其可以被操作系统使用。
在线内存的过程包括两个步骤：1. 将内存添加到系统中；2. 将内存标记为在线状态，使其可以被操作系统使用。
在这个文件中，有一些函数用于在线内存，例如online_pages_range()和generic_online_page()。
其中，generic_online_page()函数用于将单个页面标记为在线状态。

# NUMA内存策略
结构，其中每个处理器可以访问本地内存，也可以访问其他处理器的内存。NUMA系统中的内存访问时间不同，这是由于不同的内存位于不同的节点上，而节点之间的距离不同。
为了充分利用NUMA系统的性能，需要使用NUMA内存策略。Linux内核的NUMA内存策略允许用户指定内存分配的节点。它支持四种策略：interleave、bind、preferred和default。

interleave策略将内存交错分配到一组节点上，如果分配失败，则使用默认策略。对于基于VMA的分配，它是基于回退对象的偏移量或匿名内存映射的偏移量进行交错分配的。对于进程策略，使用进程计数器进行交错分配。
bind策略只在特定的一组节点上分配内存，如果分配失败，则不会回退。FIXME：内存是从第一个节点开始分配的。如果bind策略真正限制了内存节点的分配，那么它会更好。
preferred策略首先尝试在特定的一个节点上分配内存，如果分配失败，则使用默认策略。作为一个特例，NUMA_NO_NODE表示在本地CPU上进行分配。这通常与默认策略相同，但在VMA中设置非默认进程策略时很有用。
default策略首先尝试在本地节点上分配内存，如果分配失败，则使用进程策略。这是Linux在NUMA感知内核中一直使用的策略，也是默认策略。
以上策略中，VMA策略优先于进程策略

# TLB shootdown
TLB shootdown是指在多处理器系统中，当一个处理器修改了页表时，需要通知其他处理器刷新TLB中的相关项。这个文件中的函数用于收集需要刷新的TLB项，并将它们发送到其他处理器。

# mmu_notifier
用于通知内存映射关系的变化。

# mremap
mremap系统调用可以用来将一个进程的虚拟地址空间中的一段区域移动到另一个位置，或者改变这段区域的大小。

# msync
用于同步内存映射区域和文件的内容。

# oom
用来杀死进程的，当系统内存不足时，会调用这个文件中的函数来杀死一些进程，以释放内存。

# 页面隔离
页面隔离是指将一段物理内存中的页面标记为不可分配，这些页面将不会被再次分配。
这个文件中的函数可以将一段物理内存中的页面标记为隔离状态，也可以将隔离状态的页面恢复为可分配状态。
这个文件中的函数还提供了一些辅助函数，用于测试一段物理内存中的页面是否已经被隔离。

# page poison
它的主要作用是在内核中实现页面污染（page poisoning）的功能。页面污染是一种内存错误注入技术，它可以在内存中注入特定的错误，以便在程序运行时检测到这些错误。

# tmpfs文件系统
tmpfs文件系统是一种基于内存的文件系统，用于存储临时文件和文件系统的缓存。
它的主要特点是速度快，因为它不需要进行磁盘I/O操作，而是直接在内存中进行操作。此外，tmpfs还可以自动调整大小，以适应系统内存的变化。

# “随机分配”的内存分配算法
“随机分配”是一种内存分配算法，它的目的是减少内存分配的可预测性，从而增加攻击者猜测内存布局的难度。
这个算法的实现在 __shuffle_zone 函数中，它会对一个内存区域中的空闲页进行随机交换。
具体来说，它会对一个内存区域中的空闲页进行随机交换，从而打乱空闲页的顺序，使得攻击者更难以猜测下一个内存分配的位置。

# slab
它是一种内核内存分配器，用于分配小块内存。它的实现基于slab的概念，即将内存分配为一系列slab，每个slab包含多个对象，每个对象都是相同大小的。
这个文件实现了slab分配器的所有功能，包括对象的分配和释放，slab的分配和释放，以及对多个CPU的支持。

# slob
slob.c是一个简单的内存分配器，它是一个传统的K&R风格的堆分配器，支持返回对齐的对象。
堆的粒度可以小至2字节，但通常大多数体系结构将需要32位上的4字节和64位上的8字节。
slob堆是从alloc_pages()中分配的页面的一组链接列表，并且在每个页面内部，有一个自由块（slob_t）的单向链接列表。
堆是按需增长的。为了减少碎片，堆页面被分为三个列表，其中对象小于256字节，对象小于1024字节，以及所有其他对象。
从堆中分配涉及首先搜索具有足够空闲块的页面（使用类似于next-fit的方法），然后进行页面的首次适配扫描。
解除分配将对象按地址顺序插入回空闲列表中，因此这实际上是一个地址排序的首次适配。在此之上是kmalloc/kfree的实现。
从kmalloc返回的块以kmalloc大小的4字节头开始。如果kmalloc要求PAGE_SIZE或更大的对象，则直接调用alloc_pages()，分配复合页面，因此不必单独跟踪页面顺序。
这些对象在kfree()中被检测到，因为PageSlab()对它们是错误的。SLAB在SLOB之上模拟，只需为每个SLAB分配调用构造函数和析构函数。
对象以4字节对齐返回，除非设置了SLAB_HWCACHE_ALIGN标志，此时低级分配器将破碎块以创建正确的对齐。同样，通过调用alloc_pages()来分配大于页面大小的对象。
由于SLAB对象知道它们的大小，因此不需要单独的大小

# slub
这个文件是SLUB内存分配器的实现。SLUB是一种基于slab的内存分配器，它使用了一些新的技术来减少缓存行的使用，从而提高性能。
SLUB使用了一些新的同步机制，如per slab locks和atomic operations，以及一些新的数据结构，如per cpu slab和per node list。SLUB还支持一些高级特性，如CPU partial slabs和debugging。

# z3fold
z3fold是一个专门用于存储压缩页面的分配器，它可以在一页中存储多达三个压缩页面，从而提高了zbud的压缩比，同时保留了其主要概念（例如始终存储每个页面的整数对象）和简单性。
它仍然具有简单和确定性的回收属性，使其在使用回收时优于更高密度的方法（对页面上的对象数没有要求）。
z3fold将页面分为“块”。块的大小在编译时固定，并由NCHUNKS_ORDER确定。z3fold不导出任何API，而是通过zpool API使用。

# zbud
这个文件实现了一个专门用于存储压缩页面的分配器zbud。与其名称所暗示的相反，zbud不是伙伴分配器，而是将两个压缩页面“伙伴”在一起放在单个内存页面中的分配器。
zbud页面被分成“块”，块的大小在编译时固定，并由NCHUNKS_ORDER确定。将zbud页面分成块允许根据zbud页面中可用的空闲块数将未伙伴的zbud页面组织到可管理的未伙伴列表中。
zbud API与常规分配器的API不同，因为分配函数zbud_alloc()返回一个不透明的句柄，而不是可解引用的指针。用户必须使用zbud_map()将句柄映射到可用于访问分配数据的可用指针，并使用zbud_unmap()在完成对分配数据的操作时取消映射句柄。
zbud_reclaim_page()函数用于从zbud池中回收页面。zbud reclaim与正常系统回收不同，因为回收是从底部向上进行的。这是因为只有底层zbud具有关于如何在每个zbud页面中组织分配的信息。
zbud_reclaim_page()将从池LRU列表中删除zbud页面，并使用池和句柄作为参数调用用户定义的驱逐处理程序。如果无法驱逐句柄，则驱逐处理程序应返回非零。
zbud_reclaim_page()将将zbud页面添加回适当的列表，并尝试LRU上的下一个zbud页面，最多重试用户定义的次数。如果成功驱逐了zbud页面中的所有伙伴，则可以释放zbud页面。
zbud_create_pool()函数用于创建新的zbud池。


